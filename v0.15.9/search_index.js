var documenterSearchIndex = {"docs":
[{"location":"indexing_behavior/#Indexing-Behavior-1","page":"Indexing Behavior","title":"Indexing Behavior","text":"","category":"section"},{"location":"indexing_behavior/#Views-and-slices-1","page":"Indexing Behavior","title":"Views and slices","text":"","category":"section"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"ComponentArrays slice, rather than view, when indexing. This catches some people by surprise when they are trying to use indexing on ComponentVectors for dynamic field access. Let's look at an example. We'll make a ComponentVector with a nested structure.","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> using ComponentArrays\n\njulia> ca = ComponentArray(a=5, b=[4, 1])\nComponentVector{Int64}(a = 5, b = [4, 1])","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"Using dot notation, we can access and change properties as if ca was a regular struct or NamedTuple.","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> ca.b[1] = 99;\n\njulia> ca.a = 22;\n\njulia> ca\nComponentVector{Int64}(a = 22, b = [99, 1])","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"Now let's try with indexing:","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> ca[:b][1] = 0\n0\n\njulia> ca[:a] = 0\n\njulia> ca\nComponentVector{Int64}(a = 0, b = [99, 1])","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"We see that the a field changed but the b field didn't. When we did ca[:b], it sliced into ca, thus creating a copy that would not update the original when we went to set the first element to 0. On the other hand, since the update of the a field calls setindex! which updates in-place.","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"If viewing, rather than slicing, is the desired behavior, use the @view macro or view function:","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> @view(ca[:b])[1] = 0\n\njulia> ca\nComponentVector{Int64}(a = 0, b = [0, 1])","category":"page"},{"location":"indexing_behavior/#Indexing-with-multiple-symbols-1","page":"Indexing Behavior","title":"Indexing with multiple symbols","text":"","category":"section"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"It is often useful to create a new ComponentArray with only select fields of an old one. For this reason, ComponentArrays can be indexed with multiple symbolic names:","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> ca = ComponentArray(a=5, b=[4, 1], c=(a=2, b=[6, 30.0]))\nComponentVector{Float64}(a = 5.0, b = [4.0, 1.0], c = (a = 2.0, b = [6.0, 30.0]))\n\njulia> ca[(:c, :a)]\nComponentVector{Float64}(c = (a = 2.0, b = [6.0, 30.0]), a = 5.0)\n\njulia> @view ca[(:c, :a)]\nComponentVector{Float64,SubArray...}(c = (a = 2.0, b = [6.0, 30.0]), a = 5.0)","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"We see here that the new ComponentArray has the order of the a and c fields switched according to the order they were indexed by.","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"Multi-symbol indexing can be performed by passing either a Tuple or an Array of Symbols.","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> ca[[:c, :a]] == ca[(:c, :a)]\ntrue","category":"page"},{"location":"indexing_behavior/#Retaining-component-labels-through-index-operations-1","page":"Indexing Behavior","title":"Retaining component labels through index operations","text":"","category":"section"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"Sometimes you might want to index into a ComponentArray without dropping the component name. Let's look at a new example with a more deeply nested structure:","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> ca = ComponentArray(a=5, b=[4, 1], c=(a=2, b=[6, 30]))\nComponentVector{Int64}(a = 5, b = [4, 1], c = (a = 2, b = [6, 30]))","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"If we wanted to get the b component while keeping the name, we can use the KeepIndex wrapper around our index:","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> ca[KeepIndex(:b)]\nComponentVector{Int64}(b = [4, 1])","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"Now instead of just returning a plain Vector, this returns a ComponentVector that keeps the b name. Of course, this is still compatible with views, so we could have done @view ca[KeepIndex(:b)] if we wanted to retain the view into the origianl.","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"Similarly, we can use plain indexes like ranges or integers and they will keep the names of any components they capture:","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> ca[KeepIndex(1)]\nComponentVector{Int64}(a = 5)\n\njulia> ca[KeepIndex(2:3)]\nComponentVector{Int64}(b = [4, 1])\n\njulia> ca[KeepIndex(1:3)]\nComponentVector{Int64}(a = 5, b = [4, 1])\n\njulia> ca[KeepIndex(2:end)]\nComponentVector{Int64}(b = [4, 1], c = (a = 2, b = [6, 30]))","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"But what if our range doesn't capture a full component? We can see below that using KeepIndex on the first five elements returns a ComponentVector with those elements but only the a and b names, since the c component wasn't fully captured. ","category":"page"},{"location":"indexing_behavior/#","page":"Indexing Behavior","title":"Indexing Behavior","text":"julia> ca[KeepIndex(1:5)]\n5-element ComponentVector{Int64} with axis Axis(a = 1, b = 2:3):\n 5\n 4\n 1\n 2\n 6","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [ComponentArrays]","category":"page"},{"location":"api/#ComponentArrays.Axis","page":"API","title":"ComponentArrays.Axis","text":"ax = Axis(nt::NamedTuple)\n\nGives named component access for ComponentArrays.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> ax = Axis((a = 1, b = ViewAxis(2:7, PartitionedAxis(2, (a = 1, b = 2))), c = ViewAxis(8:10, (a = 1, b = 2:3))));\n\njulia> A = [100, 4, 1.3, 1, 1, 4.4, 0.4, 2, 1, 45];\n\njulia> ca = ComponentArray(A, ax)\nComponentVector{Float64}(a = 100.0, b = [(a = 4.0, b = 1.3), (a = 1.0, b = 1.0), (a = 4.4, b = 0.4)], c = (a = 2.0, b = [1.0, 45.0]))\n\njulia> ca.a\n100.0\n\njulia> ca.b\n3-element LazyArray{ComponentVector{Float64,SubArray...}}:\n ComponentVector{Float64,SubArray...}(a = 4.0, b = 1.3)\n ComponentVector{Float64,SubArray...}(a = 1.0, b = 1.0)\n ComponentVector{Float64,SubArray...}(a = 4.4, b = 0.4)\n\njulia> ca.c\nComponentVector{Float64,SubArray...}(a = 2.0, b = [1.0, 45.0])\n\njulia> ca.c.b\n2-element view(::Vector{Float64}, 9:10) with eltype Float64:\n  1.0\n 45.0\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ComponentArray","page":"API","title":"ComponentArrays.ComponentArray","text":"x = ComponentArray(nt::NamedTuple)\nx = ComponentArray(;kwargs...)\nx = ComponentArray(data::AbstractVector, ax)\nx = ComponentArray{T}(args...; kwargs...) where T\n\nArray type that can be accessed like an arbitrary nested mutable struct.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> x = ComponentArray(a=1, b=[2, 1, 4], c=(a=2, b=[1, 2]))\nComponentVector{Int64}(a = 1, b = [2, 1, 4], c = (a = 2, b = [1, 2]))\n\njulia> x.c.a = 400; x\nComponentVector{Int64}(a = 1, b = [2, 1, 4], c = (a = 400, b = [1, 2]))\n\njulia> x[5]\n400\n\njulia> collect(x)\n7-element Vector{Int64}:\n   1\n   2\n   1\n   4\n 400\n   1\n   2\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ComponentMatrix","page":"API","title":"ComponentArrays.ComponentMatrix","text":"x = ComponentMatrix(data::AbstractMatrix, ax...)\nx = ComponentMatrix{T}(data::AbstractMatrix, ax...) where T\n\nA ComponentMatrix is an alias for a two-dimensional ComponentArray.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ComponentVector","page":"API","title":"ComponentArrays.ComponentVector","text":"x = ComponentVector(nt::NamedTuple)\nx = ComponentVector(;kwargs...)\nx = ComponentVector(data::AbstractVector, ax)\nx = ComponentVector{T}(args...; kwargs...) where T\n\nA ComponentVector is an alias for a one-dimensional ComponentArray.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.KeepIndex","page":"API","title":"ComponentArrays.KeepIndex","text":"KeepIndex(idx)\n\nTag an index of a ComponentArray to retain it's Axis through indexing\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.PartitionedAxis","page":"API","title":"ComponentArrays.PartitionedAxis","text":"pa = PartitionedAxis(partition_size, index_map)\n\nAxis for creating arrays of ComponentArrays\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ShapedAxis","page":"API","title":"ComponentArrays.ShapedAxis","text":"sa = ShapedAxis(shape, index_map)\n\nPreserves higher-dimensional array components in ComponentArrays (matrix components, for example)\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ViewAxis","page":"API","title":"ComponentArrays.ViewAxis","text":"va = ViewAxis(parent_index, index_map)\n\nAxis for creating arrays of ComponentArrays\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.getaxes-Tuple{ComponentArray}","page":"API","title":"ComponentArrays.getaxes","text":"getaxes(x::ComponentArray)\n\nAccess .axes field of a ComponentArray. This is different than axes(x::ComponentArray), which     returns the axes of the contained array.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> ax = Axis(a=1:3, b=(4:6, (a=1, b=2:3)))\nAxis(a = 1:3, b = (4:6, (a = 1, b = 2:3)))\n\njulia> A = zeros(6,6);\n\njulia> ca = ComponentArray(A, (ax, ax))\n6×6 ComponentMatrix{Float64} with axes Axis(a = 1:3, b = (4:6, (a = 1, b = 2:3))) × Axis(a = 1:3, b = (4:6, (a = 1, b = 2:3)))\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> getaxes(ca)\n(Axis(a = 1:3, b = (4:6, (a = 1, b = 2:3))), Axis(a = 1:3, b = (4:6, (a = 1, b = 2:3))))\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.getdata-Tuple{ComponentArray}","page":"API","title":"ComponentArrays.getdata","text":"getdata(x::ComponentArray)\n\nAccess .data field of a ComponentArray, which contains the array that ComponentArray wraps.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.label2index-Tuple{ComponentVector{T, A, Axes} where {T, A, Axes}, Any}","page":"API","title":"ComponentArrays.label2index","text":"label2index(x::ComponentVector, str::AbstractString)\nlabel2index(label_array, str::AbstractString)\n\nConvert labels made by labels function to an array of flat indices of a ComponentVector.\n\nExamples\n\njulia> x = ComponentArray(a=5, b=[(a=(a=20,b=1), b=0), (a=(a=33,b=1), b=0)], c=(a=(a=2, b=[1,2]), b=[1. 2.; 5 6]))\nComponentVector{Float64}(a = 5.0, b = [(a = (a = 20.0, b = 1.0), b = 0.0), (a = (a = 33.0, b = 1.0), b = 0.0)], c = (a = (a = 2.0, b = [1.0, 2.0]), b = [1.0 2.0; 5.0 6.0]))\n\njulia> ComponentArrays.labels(x)\n14-element Vector{String}:\n \"a\"\n \"b[1].a.a\"\n \"b[1].a.b\"\n \"b[1].b\"\n \"b[2].a.a\"\n \"b[2].a.b\"\n \"b[2].b\"\n \"c.a.a\"\n \"c.a.b[1]\"\n \"c.a.b[2]\"\n \"c.b[1,1]\"\n \"c.b[2,1]\"\n \"c.b[1,2]\"\n \"c.b[2,2]\"\n\njulia> ComponentArrays.label2index(x, \"c.a\")\n3-element Vector{Int64}:\n  8\n  9\n 10\n\njulia> ComponentArrays.label2index(x, \"b[1]\")\n3-element Vector{Int64}:\n 2\n 3\n 4\n\nsee also labels\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.labels-Tuple{ComponentVector{T, A, Axes} where {T, A, Axes}}","page":"API","title":"ComponentArrays.labels","text":"labels(x::ComponentVector)\n\nGet string labels for for each index of a ComponentVector. Useful for automatic plot legend labelling.\n\nExamples\n\njulia> x = ComponentArray(a=5, b=[(a=(a=20,b=1), b=0), (a=(a=33,b=1), b=0)], c=(a=(a=2, b=[1,2]), b=[1. 2.; 5 6]))\nComponentVector{Float64}(a = 5.0, b = [(a = (a = 20.0, b = 1.0), b = 0.0), (a = (a = 33.0, b = 1.0), b = 0.0)], c = (a = (a = 2.0, b = [1.0, 2.0]), b = [1.0 2.0; 5.0 6.0]))\n\njulia> ComponentArrays.labels(x)\n14-element Vector{String}:\n \"a\"\n \"b[1].a.a\"\n \"b[1].a.b\"\n \"b[1].b\"\n \"b[2].a.a\"\n \"b[2].a.b\"\n \"b[2].b\"\n \"c.a.a\"\n \"c.a.b[1]\"\n \"c.a.b[2]\"\n \"c.b[1,1]\"\n \"c.b[2,1]\"\n \"c.b[1,2]\"\n \"c.b[2,2]\"\n\nsee also label2index\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.valkeys-Tuple{AbstractAxis}","page":"API","title":"ComponentArrays.valkeys","text":"valkeys(x::ComponentVector)\nvalkeys(x::AbstractAxis)\n\nReturns Val-wrapped keys of ComponentVector for fast iteration over component keys. Also works directly on an AbstractAxis.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> ca = ComponentArray(a=1, b=[1,2,3], c=(a=4,))\nComponentVector{Int64}(a = 1, b = [1, 2, 3], c = (a = 4))\n\njulia> [ca[k] for k in valkeys(ca)]\n3-element Array{Any,1}:\n 1\n  [1, 2, 3]\n  ComponentVector{Int64,SubArray...}(a = 4)\n\njulia> sum(prod(ca[k]) for k in valkeys(ca))\n11\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.LazyArray","page":"API","title":"ComponentArrays.LazyArray","text":"LazyArray(gen::Base.Generator)\n\nWrapper around Base.Generator that also indexes like an array. This is needed to make ComponentArrays that hold arrays of ComponentArrays\n\n\n\n\n\n","category":"type"},{"location":"examples/adaptive_control/#Model-Reference-Adaptive-Control-1","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"","category":"section"},{"location":"examples/adaptive_control/#Motivation-1","page":"Model Reference Adaptive Control","title":"Motivation","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Adaptive control is a good example of the type of problem that would be difficult to handle in a differential equations library without some sort of component system. We'll see how easy ComponentArrays make it to swap out subsystems, even when they have a different number of internal states.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"This specific example will walk through a typical adaptive control problem with online parameter estimation. For offline parameter estimation, check out the DifferentialEquations.jl docs.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"using ComponentArrays\nusing ControlSystems\nusing DifferentialEquations\nusing UnPack\nusing Plots","category":"page"},{"location":"examples/adaptive_control/#Helper-Functions-1","page":"Model Reference Adaptive Control","title":"Helper Functions","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"These helper functions will eventually make it into a separate package aimed at simulating control systems problems. The idea is to make it easier to bring linear models from ControlSystems.jl into nonlinear simulations in DifferentialEquations.jl. For now, we'll just define everything we need here.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"First, we need a way to apply inputs to the system through keyword arguments. These will help us pass in inputs as either values or functions of (x,p,t).","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"maybe_apply(f::Function, x, p, t) = f(x, p, t)\nmaybe_apply(f, x, p, t) = f\n\nfunction apply_inputs(func; kwargs...)\n    simfun(dx, x, p, t) = func(dx, x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    simfun(x, p, t) = func(x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    return simfun\nend\n","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Next, we need a way to create derivative functions from transfer functions. In ControlSystems.jl there is a function called simulator that does this, but the inputs must be applied from the start so we couldn't use it as a component function. Our version allows inputs to be passed through the keyword arguments and, as an added convenience, is in a transposed observer canonical form so our first element of x is also the output y (note that while this is true for our problem, it isn't always going to be the case).","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"SISO_simulator(P::TransferFunction) = SISO_simulator(ss(P))\nfunction SISO_simulator(P::AbstractStateSpace)\n    @unpack A, B, C, D = P\n\n    if size(D)!=(1,1)\n        error(\"This is not a SISO system\")\n    end\n\n    # Put into transposed observer canonical form so the first element is also the y value\n    BB = reverse(vec(C))\n    CC = reverse(vec(B))'\n    DD = D[1,1]\n    \n    return function sim!(dx, x, p, t; u=0.0)\n        dx .= A*x + BB*u\n        return CC*x + DD*u\n    end\nend","category":"page"},{"location":"examples/adaptive_control/#Laplace-Domain-Model-Specification-1","page":"Model Reference Adaptive Control","title":"Laplace Domain Model Specification","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Using ControlSystems.jl we'll make a Laplace variable s.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"s = tf(\"s\")","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"We can build a reference model in the Laplace domain","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"am = 3\nbm = 3\nref_model = bm / (s + am)\nref_sim! = SISO_simulator(ref_model)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"and our plant model as well. The nominal plant model structure is what is known to our adaptation law.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"ap = 1\nbp = 2\nnominal_plant = bp / (s + ap)\nnominal_sim! = SISO_simulator(nominal_plant)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"To test robustness to uncertainty, we'll also include unmodeled dynamics with an entirely different structure than our nominal plant model.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"unmodeled_dynamics = 229/(s^2 + 30s + 229)\ntruth_plant = nominal_plant * unmodeled_dynamics\ntruth_sim! = SISO_simulator(truth_plant)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Let's do a quick sanity check to make sure our nominal and truth plant dynamics are about the same. We'll use the apply_inputs function to plot a step response and a sine response.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"step_p = plot(solve(ODEProblem(apply_inputs(truth_sim!; u=1), truth_ic, (0.0, 10.0))); vars=1, label=\"truth model\")\nplot!(step_p, solve(ODEProblem(apply_inputs(nominal_sim!; u=1), nominal_ic, (0.0, 10.0))); vars=1, label=\"nominal model\")\n\nu = (x,p,t) -> sin(3t)\nsin_p = plot(solve(ODEProblem(apply_inputs(truth_sim!; u=u), truth_ic, (0.0, 10.0))); vars=1, label=\"truth model\")\nplot!(sin_p, solve(ODEProblem(apply_inputs(nominal_sim!; u=u), nominal_ic, (0.0, 10.0))); vars=1, label=\"nominal model\")\n\nplot(step_p, sin_p; layout=(2,1), size=(800, 800))","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"We'll make a first-order sensor as well so we can add noise to our measurement.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"τ = 0.005\nsensor_plant = 1 / (τ*s + 1)\nsensor_sim! = SISO_simulator(sensor_plant)","category":"page"},{"location":"examples/adaptive_control/#Derivative-Functions-1","page":"Model Reference Adaptive Control","title":"Derivative Functions","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Our control law assumes perfect knowledge of the parameters that are attached to the regressors (which are the reference input and the model output)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"control(θ, w) = θ'w","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"We'll use a simple gradient descent adaptation law","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"function adapt!(Dθ, θ, γ, t; e, w)\n    Dθ .= -γ*e*w\n    return nothing\nend","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Our feedback loop takes in the reference model output ym and the input signal r, calculates the control signal u, feeds that into the plant model, calculates the reference tracking error e, and finally updates feeds the reference tracking error and it's corresponding regressor vector to the adaptation law.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"function feedback_sys!(D, vars, p, t; ym, r, n)\n    @unpack parameter_estimates, plant_model, sensor = vars\n    γ = p.gamma\n    regressor = [r, plant_model[1]]\n\n    u = control(parameter_estimates, regressor)\n    yp = p.plant_fun(D.plant_model, plant_model, (), t; u=u)\n    ŷ = sensor_sim!(D.sensor, sensor, (), t; u=yp[1]) + n\n    e = ŷ .- ym\n    regressor[2] = ŷ\n    adapt!(D.parameter_estimates, parameter_estimates, γ, t; e=e, w=regressor)\n    return yp\nend","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Now the full system takes in an input signal r, feeds it through the reference model, and feeds the output of the reference model ym and the input signal to feedback_sys.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"function system!(D, vars, p, t; r=0.0, n=0.0)\n    @unpack reference_model, feedback_loop = vars\n\n    ym = ref_sim!(D.reference_model, reference_model, (), t; u=r)\n    yp = feedback_sys!(D.feedback_loop, feedback_loop, p, t; ym=ym, r=r, n=n)\n    return yp\nend","category":"page"},{"location":"examples/adaptive_control/#Simulation-Inputs-1","page":"Model Reference Adaptive Control","title":"Simulation Inputs","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"# Simulation time span\ntspan = (0.0, 30.0)\n\n# Input signal\ninput_signal = (x,p,t) -> sin(3t)\n\n# Initial conditions\nref_ic = zeros(1)\nnominal_ic = zeros(1)\ntruth_ic = zeros(3)\nsensor_ic = zeros(1)\nθ_est_ic = ComponentArray(θr=0.0, θy=0.0)","category":"page"},{"location":"examples/adaptive_control/#Set-Up-Simulation-1","page":"Model Reference Adaptive Control","title":"Set Up Simulation","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"function simulate(plant_fun, plant_ic;\n                tspan=tspan,\n                input_signal=input_signal,\n                adapt_gain=1.5,\n                noise_param=nothing,\n                deterministic_noise=0.0)\n\n    noise(D, vars, p, t) = (D.feedback_loop.sensor[1] = noise_param)\n\n    # Truth control parameters\n    θ_truth = (r=bm/bp, y=(ap-am)/bp)\n\n    # Initial conditions\n    ic = ComponentArray(\n        reference_model = ref_ic,\n        feedback_loop = (\n            parameter_estimates = θ_est_ic,\n            sensor = sensor_ic,\n            plant_model = plant_ic,\n        ),\n    )\n\n    # Model parameters\n    p = (\n        gamma = adapt_gain,\n        plant_fun = plant_fun,\n    )\n\n    sim_fun = apply_inputs(system!; r=input_signal, n=deterministic_noise)\n\n    # We can also choose whether we want to include random noise in our model by switching between an ODE\n    # and an SDE problem.\n    if noise_param === nothing\n        prob = ODEProblem(sim_fun, ic, tspan, p, max_iters=2000)\n    else\n        prob = SDEProblem(sim_fun, noise, ic, tspan, p, max_iters=2000)\n    end\n\n\n    ## Solve!\n    sol = solve(prob)\n\n\n    ## Plot\n    # Reference model tracking\n    top = plot(\n        sol,\n        vars=[\"reference_model[1]\", \"feedback_loop.sensor\"],\n        legend=:right,\n        title=\"Reference Model Tracking\",\n    )\n\n    # Parameter estimate tracking\n    bottom = plot(sol, vars=\"feedback_loop.parameter_estimates\")\n    plot!(\n        bottom,\n        [tspan...], [θ_truth.r θ_truth.y; θ_truth.r θ_truth.y],\n        labels=[\"θr truth\" \"θy truth\"],\n        legend=:right,\n        title=\"Parameter Estimate Tracking\",\n    )\n\n    # Combine both plots\n    plot(top, bottom, layout=(2,1), size=(800, 800))\nend","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"And now let's run the simulation and plot.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"simulate(nominal_sim!, nominal_ic; noise_param=0.2)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#Unmodeled-Dynamics-1","page":"Model Reference Adaptive Control","title":"Unmodeled Dynamics","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Notice our parameter estimates are converging to a slightly different number than the truth values. This is because we didn't take the sensor dynamics into account in our adaptation law. Thankfully we are pretty robust to this. Let's push it a little further though. Remember our truth plant model with the extra unmodelled dynamics? Let's plot that one up now. Notice how easy it ComponentArrays make it to switch out the two simulations, despite the fact that the two plant models have a different number of states. ","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"simulate(truth_sim!, truth_ic; noise_param=0.2)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Even though our parameters aren't tracking what we think they should be, we are still tracking our reference model well. In real systems, there are always going to be unaccounted-for dynamics, so it's important that we are robust to that.","category":"page"},{"location":"examples/adaptive_control/#Insufficient-Excitation-and-Rohr's-Example-1","page":"Model Reference Adaptive Control","title":"Insufficient Excitation and Rohr's Example","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Readers familiar with adaptive control might have noticed that our plant model parameters weren't just arbitrarily chosen; they come from Rohr's well-known example of parameter drift for insufficient excitation. To see this in action, let's look at what happens when we feed our model a stationary input. We'll switch to the same purely deterministic noise model that Rohr used. The parameter adaptation gain is a best guess to match the original data.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"simulate(nominal_sim!, nominal_ic;\n        input_signal = 2.0,\n        deterministic_noise = (x,p,t) -> 0.5sin(16.1t),\n        noise_param = nothing,\n        tspan = (0.0, 100.0),\n        adapt_gain = 3.35)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Interesting. If we were just looking at the model reference tracking, it would seem that everything is okay. The parameters are drifting within a space that keeps the reference tracking error small. This is pretty typical for \"insufficiently excited\" systems, i.e. systems whose input is either flat or at frequencies that are attenuated by the plant dynamics. Now let's see what happens with our truth model.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"simulate(truth_sim!, truth_ic;\n           input_signal = 2.0,\n           deterministic_noise = (x,p,t) -> 0.5sin(16.1t),\n           noise_param = nothing,\n           tspan = (0.0, 72.9),\n           adapt_gain = 3.35)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Yikes! It looks like that parameter drift can lead to system instability. We won't go into the strategies to mitigate this problem here, but if you're interested, check out Slotine and Li's Applied Nonlinear Control.","category":"page"},{"location":"quickstart/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#General-use-1","page":"Quick Start","title":"General use","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The easiest way to construct 1-dimensional ComponentArrays is as if they were NamedTuples. In fact, a good way to think about them is as arbitrarily nested, mutable NamedTuples that can be passed through a solver.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> c = (a=2, b=[1, 2]);\n\njulia> x = ComponentArray(a=1.0, b=[2, 1, 4], c=c)\nComponentVector{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n\njulia> x.c.a = 400; x\nComponentVector{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 400.0, b = [1.0, 2.0]))\n\njulia> x[5]\n400.0\n\njulia> collect(x)\n7-element Array{Float64,1}:\n   1.0\n   2.0\n   1.0\n   4.0\n 400.0\n   1.0\n   2.0\n\njulia> typeof(similar(x, Int32)) === typeof(ComponentVector{Int32}(a=1, b=[2, 1, 4], c=c))\ntrue","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"ComponentArrays can be constructed from existing ComponentArrays (currently nested fields cannot be changed this way):","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> x = ComponentVector(a=1, b=2, c=3);\n\njulia> ComponentVector(x; a=11, new=42)\nComponentVector{Int64}(a = 11, b = 2, c = 3, new = 42)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Higher dimensional ComponentArrays can be created too, but it's a little messy at the moment. The nice thing for modeling is that dimension expansion through broadcasted operations can create higher-dimensional ComponentArrays automatically, so Jacobian cache arrays that are created internally with false .* x .* x' will be ComponentArrays with proper axes. Check out the ODE with Jacobian example in the examples folder to see how this looks in practice.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> x2 = x .* x'\n7×7 ComponentMatrix{Float64} with axes Axis(a = 1, b = 2:4, c = ViewAxis(5:7, Axis(a = 1, b = 2:3))) × Axis(a = 1, b = 2:4, c = ViewAxis(5:7, Axis(a = 1, b = 2:3)))\n   1.0    2.0    1.0     4.0     400.0    1.0    2.0\n   2.0    4.0    2.0     8.0     800.0    2.0    4.0\n   1.0    2.0    1.0     4.0     400.0    1.0    2.0\n   4.0    8.0    4.0    16.0    1600.0    4.0    8.0\n 400.0  800.0  400.0  1600.0  160000.0  400.0  800.0\n   1.0    2.0    1.0     4.0     400.0    1.0    2.0\n   2.0    4.0    2.0     8.0     800.0    2.0    4.0\n\njulia> x2[:c,:c]\n3×3 ComponentMatrix{Float64,SubArray...} with axes Axis(a = 1, b = 2:3) × Axis(a = 1, b = 2:3)\n 160000.0  400.0  800.0\n    400.0    1.0    2.0\n    800.0    2.0    4.0\n\njulia> x2[:a,:a]\n 1.0\n\njulia> x2[:a,:c]\nComponentVector{Float64,SubArray...}(a = 400.0, b = [1.0, 2.0])\n\njulia> x2[:b,:c]\n3×3 ComponentMatrix{Float64,SubArray...} with axes FlatAxis() × Axis(a = 1, b = 2:3)\n  800.0  2.0  4.0\n  400.0  1.0  2.0\n 1600.0  4.0  8.0","category":"page"},{"location":"examples/coulomb_control/#Control-of-a-sliding-block-1","page":"Control of a sliding block","title":"Control of a sliding block","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"using ComponentArrays\nusing DifferentialEquations\nusing Interact: @manipulate\nusing Parameters: @unpack\nusing Plots","category":"page"},{"location":"examples/coulomb_control/#Problem-Setup-1","page":"Control of a sliding block","title":"Problem Setup","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"const g = 9.80665\n\nmaybe_apply(f::Function, x, p, t) = f(x, p, t)\nmaybe_apply(f, x, p, t) = f\n\n# Applies functions of form f(x,p,t) to be applied and passed in as inputs\nfunction simulator(func; kwargs...)\n    simfun(dx, x, p, t) = func(dx, x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    simfun(x, p, t) = func(x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    return simfun\nend\n\nsoftsign(x) = tanh(1e3x)","category":"page"},{"location":"examples/coulomb_control/#Component-Functions-1","page":"Control of a sliding block","title":"Component Functions","text":"","category":"section"},{"location":"examples/coulomb_control/#A-sliding-block-with-two-different-friction-models-1","page":"Control of a sliding block","title":"A sliding block with two different friction models","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"# Sliding block with viscous friction\nfunction viscous_block!(D, vars, p, t; u=0.0)\n    @unpack m, c, k = p\n    @unpack v, x = vars\n\n    D.x = v\n    D.v = (-c*v + k*(u-x))/m\n    return x\nend\n\n# Sliding block with coulomb friction\nfunction coulomb_block!(D, vars, p, t; u=0.0)\n    @unpack m, μ, k = p\n    @unpack v, x = vars\n\n    D.x = v\n    a = -μ*g*softsign(v) + k*(u-x)/m\n    D.v = abs(a)<1e-3 && abs(v)<1e-3 ? -10v : a #deadzone to help the simulation\n    return x\nend","category":"page"},{"location":"examples/coulomb_control/#PID-feedback-control-1","page":"Control of a sliding block","title":"PID feedback control","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"function PID_controller!(D, vars, p, t; err=0.0, v=0.0)\n    @unpack kp, ki, kd = p\n    @unpack x = vars\n\n    D.x = ki*err\n    return x + kp*err + kd*v\nend\n\nfunction feedback_sys!(D, components, p, t; ref=0.0)\n    @unpack ctrl, plant = components\n\n    u = p.ctrl.fun(D.ctrl, ctrl, p.ctrl.params, t; err=ref-plant.x, v=-plant.v)\n    return p.plant.fun(D.plant, plant, p.plant.params, t; u=u)\nend\n\nstep_input(;time=1.0, mag=1.0) = (x,p,t) -> t>time ? mag : 0\nsine_input(;mag=1.0, period=10.0) = (x,p,t) -> mag*sin(t*2π/period)\n\n# Equivalent viscous damping coefficient taken from:\n# https://engineering.purdue.edu/~deadams/ME563/lecture2010.pdf\nvisc_equiv(μ, N, ω, mag) = 4*μ*N/(π*ω*mag)","category":"page"},{"location":"examples/coulomb_control/#Open-Loop-Response-1","page":"Control of a sliding block","title":"Open-Loop Response","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"To see the open-loop response of the coulomb system, let's set the input to 5 and plot the results. ","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"const tspan = (0.0, 30.0)\nconst m = 50.0\nconst μ = 0.1\nconst k = 50.0\n\np = (m=m, μ=μ, k=k)\nic = ComponentArray(v=0, x=0)\n\nODEProblem(simulator(coulomb_block!, u=5), ic, tspan, p) |> solve |> plot","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"(Image: )","category":"page"},{"location":"examples/coulomb_control/#Closed-Loop-Response-1","page":"Control of a sliding block","title":"Closed-Loop Response","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"For the closed-loop response, let's make an interactive GUI. Since we are using ComponentArrays, we don't have to change anything about our plant model to incorporate it in the overall system simulation.","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"p = (\n    ctrl = (\n        params = (kp=13, ki=12, kd=5),\n        fun = PID_controller!,\n    ),\n    plant = (\n        params = plant_p,\n        fun = coulomb_block!,\n    ),\n)\n\nic = ComponentArray(ctrl=(;x=0), plant=plant_ic)\n\nsol = ODEProblem(simulator(feedback_sys!, ref=10), ic, tspan, p) |> solve\nplot(sol, vars=3)","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"## Interactive GUI for switching out plant models and varying PID gains\n@manipulate for kp in 0:0.01:15,\n                ki in 0:0.01:15, \n                kd in 0:0.01:15,\n                damping in Dict(\n                    \"Coulomb\" => coulomb_block!,\n                    \"Viscous\" => viscous_block!,\n                ),\n                reference in Dict(\n                    \"Sine\" => sine_input,\n                    \"Step\" => step_input,\n                ),\n                magnitude in 0:0.01:10, # pop-pop!\n                period in 1:0.01:30,\n                plot_v in false\n    \n    # Inputs\n    tspan = (0.0, 30.0)\n\n    ctrl_fun = PID_controller!\n    # plant_fun = coulomb_block!\n    \n    ref = if reference==sine_input\n        reference(period=period, mag=magnitude)\n        else\n        reference(mag=magnitude)\n    end\n    \n    m = 50.0\n    μ = 0.1\n    ω = 2π/period\n    c = 4*μ*m*g/(π*ω*magnitude) # Viscous equivalent damping\n    k = 50.0\n\n    plant_p = (m=m, μ=μ, c=c, k=k) # We'll just put everything for both models in here\n    ctrl_p = (kp=kp, ki=ki, kd=kd)\n\n    plant_ic = (v=0, x=0)\n    ctrl_ic = (;x=0)\n\n\n\n    # Set up and solve\n    sys_p = (\n        ctrl = (\n            params = ctrl_p,\n            fun = ctrl_fun,\n        ),\n        plant = (\n            params = plant_p,\n            fun = damping,\n        ),\n    )\n    sys_ic = ComponentArray(ctrl=ctrl_ic, plant=plant_ic)\n    sys_fun = ODEFunction(simulator(feedback_sys!, ref=ref), syms=[:u, :v, :x])\n    sys_prob = ODEProblem(sys_fun, sys_ic, tspan, sys_p)\n\n    sol = solve(sys_prob, Tsit5())\n\n\n    # Plot\n    t = tspan[1]:0.1:tspan[2]\n    lims = magnitude*[-1, 1]\n    plotvars = plot_v ? [3, 2] : [3]\n    strip = plot(t, ref.(0, 0, t), ylim=1.2lims, label=\"r(t)\")\n    plot!(strip, sol, vars=plotvars)\n    phase = plot(ref.(0, 0, t), map(x->x.plant.x, sol(t).u),\n        xlim=lims,\n        ylim=1.2lims,\n        legend=false,\n        xlabel=\"r(t)\",\n        ylabel=\"x(t)\",\n    )\n    plot(strip, phase, layout=(2, 1), size=(700, 800))\n\nend","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"(Image: )","category":"page"},{"location":"examples/DiffEqFlux/#Neural-ODEs-with-DiffEqFlux-1","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"","category":"section"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Let's see how easy it is to make dense neural ODE layers from scratch. Flux is used here just for the glorot_uniform function and the ADAM optimizer.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"This example is taken from the DiffEqFlux documentation. ","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"using ComponentArrays\nusing OrdinaryDiffEq\nusing Plots\nusing UnPack\n\nusing DiffEqFlux: sciml_train\nusing Flux: glorot_uniform, ADAM\nusing Optim: LBFGS","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"First, let's set up the problem and create the truth data.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"u0 = Float32[2.; 0.]\ndatasize = 30\ntspan = (0.0f0, 1.5f0)\n\nfunction trueODEfunc(du, u, p, t)\n    true_A = [-0.1 2.0; -2.0 -0.1]\n    du .= ((u.^3)'true_A)'\nend\n\nt = range(tspan[1], tspan[2], length = datasize)\nprob = ODEProblem(trueODEfunc, u0, tspan)\node_data = Array(solve(prob, Tsit5(), saveat = t))","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Next we'll make a function that creates dense neural layer components. It is similar to Flux.Dense, except it doesn't handle the activation function. We'll do that separately.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"dense_layer(in, out) = ComponentArray{Float32}(W=glorot_uniform(out, in), b=zeros(out))","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Our parameter vector will be a ComponentArray that holds the ODE initial conditions and the dense neural layers.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"layers = (L1=dense_layer(2, 50), L2=dense_layer(50, 2))\nθ = ComponentArray(u=u0, p=layers)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"We now have convenient struct-like access to the weights and biases of the layers for our neural ODE function while giving our optimizer something that acts like a flat array.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"function dudt(u, p, t)\n    @unpack L1, L2 = p\n    return L2.W * tanh.(L1.W * u.^3 .+ L1.b) .+ L2.b\nend\n\nprob = ODEProblem(dudt, u0, tspan)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"predict_n_ode(θ) = Array(solve(prob, Tsit5(), u0=θ.u, p=θ.p, saveat=t))\n\nfunction loss_n_ode(θ)\n    pred = predict_n_ode(θ)\n    loss = sum(abs2, ode_data .- pred)\n    return loss, pred\nend\nloss_n_ode(θ)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Let's set up a training observation callback and train!","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"cb = function (θ, loss, pred; doplot=false)\n    display(loss)\n    # plot current prediction against data\n    pl = scatter(t, ode_data[1,:], label = \"data\")\n    scatter!(pl, t, pred[1,:], label = \"prediction\")\n    display(plot(pl))\n    return false\nend\ncb(θ, loss_n_ode(θ)...)\n\ndata = Iterators.repeated((), 1000)\n\nres1 = sciml_train(loss_n_ode, θ, ADAM(0.05); cb=cb, maxiters=100)\ncb(res1.minimizer, loss_n_ode(res1.minimizer)...; doplot=true)\n\nres2 = sciml_train(loss_n_ode, res1.minimizer, LBFGS(); cb=cb)\ncb(res2.minimizer, loss_n_ode(res2.minimizer)...; doplot=true)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"(Image: )","category":"page"},{"location":"examples/ODE_jac/#ODE-with-Jacobian-1","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"","category":"section"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"This example shows how to use ComponentArrays for composing Jacobian update functions as well as ODE functions. For most practical purposes, it is generally easier to use automatic differentiation libraries like ForwardDiff.jl, ReverseDiff.jl, or Zygote.jl for calculating Jacobians. Although those libraries all work with ComponentArrays, this is a nice way to handle it if you already have derived analytical Jacobians.","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"Note using plain symbols to index into ComponentArrays is still pretty slow. For speed, all symbolic indices should be wrapped in a Val like D[Val(:x), Val(:y)].","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"using ComponentArrays\nusing DifferentialEquations\nusing Parameters: @unpack\n\n\ntspan = (0.0, 20.0)\n\n\n## Lorenz system\nfunction lorenz!(D, u, p, t; f=0.0)\n    @unpack σ, ρ, β = p\n    @unpack x, y, z = u\n    \n    D.x = σ*(y - x)\n    D.y = x*(ρ - z) - y - f\n    D.z = x*y - β*z\n    return nothing\nend\nfunction lorenz_jac!(D, u, p, t)\n    @unpack σ, ρ, β = p\n    @unpack x, y, z = u\n    \n    D[:x,:x] = -σ\n    D[:x,:y] = σ\n\n    D[:y,:x] = ρ\n    D[:y,:y] = -1\n    D[:y,:z] = -x\n\n    D[:z,:x] = y\n    D[:z,:y] = x\n    D[:z,:z] = -β\n    return nothing\nend\n\nlorenz_p = (σ=10.0, ρ=28.0, β=8/3)\nlorenz_ic = ComponentArray(x=0.0, y=0.0, z=0.0)\nlorenz_fun = ODEFunction(lorenz!, jac=lorenz_jac!)\nlorenz_prob = ODEProblem(lorenz_fun, lorenz_ic, tspan, lorenz_p)\n\n\n## Lotka-Volterra system\nfunction lotka!(D, u, p, t; f=0.0)\n    @unpack α, β, γ, δ = p\n    @unpack x, y = u\n    \n    D.x =  α*x - β*x*y + f\n    D.y = -γ*y + δ*x*y\n    return nothing\nend\nfunction lotka_jac!(D, u, p, t)\n    @unpack α, β, γ, δ = p\n    @unpack x, y = u\n    \n    D[:x,:x] = α - β*y\n    D[:x,:y] = -β*x\n\n    D[:y,:x] = δ*y\n    D[:y,:y] = -γ + δ*x\n    return nothing\nend\n\nlotka_p = (α=2/3, β=4/3, γ=1.0, δ=1.0)\nlotka_ic = ComponentArray(x=1.0, y=1.0)\nlotka_fun = ODEFunction(lotka!, jac=lotka_jac!)\nlotka_prob = ODEProblem(lotka_fun, lotka_ic, tspan, lotka_p)\n\n\n## Composed Lorenz and Lotka-Volterra system\nfunction composed!(D, u, p, t)\n    c = p.c #coupling parameter\n    @unpack lorenz, lotka = u\n    \n    lorenz!(D.lorenz, lorenz, p.lorenz, t, f=c*lotka.x)\n    lotka!(D.lotka, lotka, p.lotka, t, f=c*lorenz.x)\n    return nothing\nend\nfunction composed_jac!(D, u, p, t)\n    c = p.c\n    @unpack lorenz, lotka = u\n    \n    lorenz_jac!(@view(D[:lorenz,:lorenz]), lorenz, p.lorenz, t)\n    lotka_jac!(@view(D[:lotka,:lotka]), lotka, p.lotka, t)\n\n    @view(D[:lorenz,:lotka])[:y,:x] = -c\n    @view(D[:lotka,:lorenz])[:x,:x] = c\n    return nothing\nend\n\ncomp_p = (lorenz=lorenz_p, lotka=lotka_p, c=0.01)\ncomp_ic = ComponentArray(lorenz=lorenz_ic, lotka=lotka_ic)\ncomp_fun = ODEFunction(composed!, jac=composed_jac!)\ncomp_prob = ODEProblem(comp_fun, comp_ic, tspan, comp_p)\n\n\n## Solve problem\n# We can solve the composed system...\ncomp_sol = solve(comp_prob, Rodas5())\n\n# ...or we can unit test one of the component systems\nlotka_sol = solve(lotka_prob, Rodas5())","category":"page"},{"location":"static_unpack/#Unpacking-to-StaticArrays-1","page":"Unpacking to StaticArrays","title":"Unpacking to StaticArrays","text":"","category":"section"},{"location":"static_unpack/#","page":"Unpacking to StaticArrays","title":"Unpacking to StaticArrays","text":"Often ComponentArrays will hold vector or matrix components for which the user will want to unpack and operate on. If these arrays are small (for example, 3-vectors of positions and velocities), it is usually useful to convert them to SArrays from StaticArrays.jl before doing operations on them to avoid heap allocations. For this reason, we export a @static_unpack macro that works similarly to @unpack from UnPack.jl, except it converts all plain arrays to SArrays. Anything that isn't a plain array (for example, scalars or inner ComponentArrays) will be unpacked as usual.","category":"page"},{"location":"static_unpack/#Example-1","page":"Unpacking to StaticArrays","title":"Example","text":"","category":"section"},{"location":"static_unpack/#","page":"Unpacking to StaticArrays","title":"Unpacking to StaticArrays","text":"julia> x = ComponentVector(a=5, b=[4, 1], c = [1 2; 3 4], d=(e=2, f=[6, 30.0]));\n\njulia> @static_unpack a, b, c, d = x;\n\njulia> a\n5.0\n\njulia> b\n2-element SVector{2, Float64} with indices SOneTo(2):\n 4.0\n 1.0\n\njulia> c\n2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):\n 1.0  2.0\n 3.0  4.0\n\njulia> d\nComponentVector{Float64,SubArray...}(e = 2.0, f = [6.0, 30.0])","category":"page"},{"location":"static_unpack/#Why-not-just-have-static-ComponentArrays?-1","page":"Unpacking to StaticArrays","title":"Why not just have static ComponentArrays?","text":"","category":"section"},{"location":"static_unpack/#","page":"Unpacking to StaticArrays","title":"Unpacking to StaticArrays","text":"Most of the places ComponentVectors are used, the top-level ComponentVector is too large to be efficiently backed by a SVector. Typically you only need the inner components to be SVectors for fast operations (for example, simulating rigid body dynamics where states and derivatives are mostly 3-vectors that need to undergo rotations and translations).","category":"page"},{"location":"static_unpack/#","page":"Unpacking to StaticArrays","title":"Unpacking to StaticArrays","text":"Also, just from experience, immutable ComponentArrays tend to be really clunky to work with.","category":"page"},{"location":"#ComponentArrays.jl-1","page":"Home","title":"ComponentArrays.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The main export of this package is the ComponentArray type. \"Components\" of ComponentArrays are really just array blocks that can be accessed through a named index. The magic here is that this named indexing can create a new ComponentArray whose data is a view into the original, allowing for standalone models to be composed together by simple function composition. In essence, ComponentArrays allow you to do the things you would usually need a modeling language for, but without actually needing a modeling language. The main targets are for use in DifferentialEquations.jl and Optim.jl, but anything that requires flat vectors is fair game.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"examples/example1.md\"]\nDepth = 2","category":"page"}]
}
